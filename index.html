<!DOCTYPE html>
<html>

<head>
    <title>Polygon project</title>
    <link rel="stylesheet" href="/bower_components/material-design-lite/material.min.css">
    <script src="/bower_components/material-design-lite/material.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">
    <style>
        body {
            font-family: Roboto;
        }
        
        input {
            width: 100%;
            border: 0;
            border-bottom: 2px solid rgba(0, 0, 0, 0.12);
            color: rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }
        
        input:focus {
            outline: none;
            color: #3F51B5;
            border-bottom-color: #3F51B5;
        }
        
        #positionWrapper {
            position: fixed;
            top: 3%;
            left: 3%;
            padding-bottom: 20px;
            width: 300px;
            border: 0;
            background: rgba(255, 255, 255, 0.9);
        }
        
        #table {
            margin-bottom: 10px;
            width: 300px;
        }
        
        #canvas,
        body,
        html {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
        
        .addButton {
            position: absolute;
            right: 10px;
        }
        
        #table th,
        #table td {
            padding: 5px 10px;
        }
        
        #table th {
            font-weight: bold;
        }
    </style>
</head>

<body onresize="ReBuild()">
    <canvas id="canvas">
    </canvas>
    <div id="positionWrapper" class="mdl-shadow--2dp">
        <table id="table">
            <thead>
                <tr>
                    <th class="mdl-data-table__cell--non-numeric">Position X</th>
                    <th class="mdl-data-table__cell--non-numeric">Position Y</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
            </tbody>
        </table>
        <button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-button--colored addButton" onclick="AddPoint()">
            <i class="material-icons">add</i>
        </button>
    </div>


    <script>
        var table = document.getElementById("table");
        var nextIndex = 0;

        function RemovePoint(index) {
            for (var i = 0; i < table.rows.length; i++) {
                if (table.rows[i].dataset.id == index) {
                    table.deleteRow(i);
                    break;
                }
            }
        }

        function CheckKey(event) {
            var key = event.keyCode || event.charCode;
            return (key >= 48 && key <= 57) || key == 8 || key == 46 || key == 45;
        }

        function AddPoint() {
            var row = table.insertRow();
            row.dataset.id = ++nextIndex;

            var cell1 = row.insertCell(0);
            var cell2 = row.insertCell(1);
            var cell3 = row.insertCell(2);

            cell1.innerHTML = "<input type='text' onkeypress='return CheckKey(event)' value='0'>";
            cell2.innerHTML = "<input type='text' onkeypress='return CheckKey(event)' value='0'>";
            cell3.innerHTML = "<button class='mdl-button mdl-js-button mdl-button--icon mdl-button--colored' onclick='RemovePoint(" + nextIndex + ")'> <i class='material-icons'>remove</i></button>";
            ReDraw();
        }

        var canvas = document.getElementById("canvas");
        ReBuild();
        var ctx = canvas.getContext("2d");

        var scale, maxSize;


        function ReBuild() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            maxSize = canvas.width > canvas.height ? canvas.height : canvas.width;
        }

        function ReDraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#000000";
            var array = [];
            scale = 9999;

            for (var i = 1; i < table.rows.length; i++) {

                var posX = parseFloat(table.rows[i].cells[0].children[0].value);
                var posY = parseFloat(table.rows[i].cells[1].children[0].value);

                if (posX != 0) {
                    scaleX = maxSize / Math.abs(posX);
                    if (scaleX < scale) scale = scaleX;
                }

                if (posY != 0) {
                    scaleY = maxSize / Math.abs(posY);
                    if (scaleY < scale) scale = scaleY;
                }

                array.push(ModifyPosition({
                    x: posX,
                    y: posY
                }));
            }


            DrawBase();
            if (array.length > 1) {
                array.push(array[0]);

                DrawLines(array);
                DrawIntersection(array);
            }
        }

        function DrawBase() {
            ctx.strokeStyle = "#ccc";
            ctx.lineWidth = 1;

            var halfWidth = canvas.width / 2;
            var halfHeight = canvas.height / 2;
            var halfMaxSize = maxSize / 2;

            ctx.beginPath();
            ctx.moveTo(halfWidth, halfHeight - halfMaxSize);
            ctx.lineTo(halfWidth, halfHeight + halfMaxSize);
            ctx.stroke();
            ctx.closePath();

            ctx.beginPath();
            ctx.moveTo(halfWidth - halfMaxSize, halfHeight);
            ctx.lineTo(halfWidth + halfMaxSize, halfHeight);
            ctx.stroke();
            ctx.closePath();
        }

        function DrawLines(array) {
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;

            for (var i = 0; i < array.length - 1; i++) {
                ctx.beginPath();
                ctx.moveTo(array[i].x, array[i].y);
                ctx.lineTo(array[i + 1].x, array[i + 1].y);
                ctx.stroke();
            }
        }

        function ModifyPosition(position) {
            var halfScale = scale * 0.48;
            var halfWidth = canvas.width / 2;
            var halfHeight = canvas.height / 2;

            return {
                x: position.x * halfScale + halfWidth,
                y: -position.y * halfScale + halfHeight
            };
        }

        var mouseX, mouseY;

        function DrawIntersection(array) {
            var halfWidth = canvas.width / 2;
            var halfHeight = canvas.height / 2;
            var halfMaxSize = maxSize / 2;

            var intersections = [];

            var mouseXLine = {
                startX: halfWidth - halfMaxSize,
                endX: halfWidth + halfMaxSize,
                startY: mouseY,
                endY: mouseY
            }

            for (var i = 0; i < array.length - 1; i++) {
                var line = {
                    startX: array[i].x,
                    startY: array[i].y,
                    endX: array[i + 1].x,
                    endY: array[i + 1].y
                }

                var result = CheckLineIntersection(mouseXLine, line);

                if (result.intersects)
                    intersections.push(result);
            }

            if (intersections.length > 0) {
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(mouseXLine.startX, mouseXLine.startY);
                ctx.lineTo(mouseXLine.endX, mouseXLine.endY);
                ctx.strokeStyle = '#9297B5';
                ctx.stroke();

                for (var i = 0; i < intersections.length; i++) {
                    ctx.beginPath();
                    ctx.arc(intersections[i].x, intersections[i].y, 5, 0, 2 * Math.PI, false);
                    ctx.fillStyle = '#3F51B5';
                    ctx.fill();
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        }

        function CheckLineIntersection(line1, line2) {
            // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
            var denominator, a, b, numerator1, numerator2, result = {
                x: null,
                y: null,
                intersects: false
            };
            denominator = ((line2.endY - line2.startY) * (line1.endX - line1.startX)) - ((line2.endX - line2.startX) * (line1.endY - line1.startY));
            if (denominator == 0) {
                return result;
            }
            a = line1.startY - line2.startY;
            b = line1.startX - line2.startX;
            numerator1 = ((line2.endX - line2.startX) * a) - ((line2.endY - line2.startY) * b);
            numerator2 = ((line1.endX - line1.startX) * a) - ((line1.endY - line1.startY) * b);
            a = numerator1 / denominator;
            b = numerator2 / denominator;

            // if we cast these lines infinitely in both directions, they intersect here:
            result.x = line1.startX + (a * (line1.endX - line1.startX));
            result.y = line1.startY + (a * (line1.endY - line1.startY));

            // if line2 is a segment and line1 is infinite, they intersect if:
            if (b > 0 && b < 1 && a > 0 && a < 1) {
                result.intersects = true;
            }
            // if line1 and line2 are segments, they intersect if both of the above are true
            return result;
        };

        canvas.addEventListener('mousemove', getPosition, false);

        function getPosition(event) {
            mouseX = event.pageX;
            mouseY = event.pageY;

            //mouseX -= canvas.offsetLeft;
            //mouseY -= canvas.offsetTop;
        }

        setInterval(ReDraw, 20);
    </script>
</body>

</html>